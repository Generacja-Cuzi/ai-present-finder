@startuml main_flow
title AI Present Finder - Main Flow (Complete with Commands & Events)

actor User as U
participant "REST API" as REST
participant "Google OAuth" as GOOGLE
participant "Chat Service" as CHAT
participant "Stalking Service" as STALK
participant "Gift Ideas Service" as GIFT
box "Fetch Microservices" #LightBlue
  participant "OLX" as FETCH_OLX
  participant "Allegro" as FETCH_ALLEGRO
  participant "eBay" as FETCH_EBAY
  participant "Amazon" as FETCH_AMAZON
end box
participant "Reranking Service" as RERANK

== Autoryzacja użytkownika ==
U -> REST: GET /auth/google/url
activate REST
REST -> REST: **GenerateGoogleOAuthUrlQuery**
REST -> GOOGLE: Get OAuth URL
REST --> U: {url: "https://accounts.google.com/..."}
deactivate REST
note left: Użytkownik przekierowuje\ndo Google OAuth

U -> GOOGLE: Autoryzacja w Google
activate GOOGLE
GOOGLE --> U: Redirect z kodem autoryzacyjnym
deactivate GOOGLE

U -> REST: POST /auth/google/callback\n{code}
activate REST
REST -> REST: **ValidateGoogleTokenCommand**
REST -> GOOGLE: Wymiana kodu na token
activate GOOGLE
GOOGLE --> REST: {accessToken, refreshToken, email, name}
deactivate GOOGLE
REST -> REST: Generate JWT token
REST --> U: Set-Cookie: access_token (httpOnly)\n{user: {id, email, name}}
deactivate REST
note left: JWT zapisany w httpOnly cookie\nDostęp do chronionych endpointów

== Start sesji (użytkownik zalogowany) ==

alt Użytkownik ma zapisane profile
  U -> REST: GET /restapi/user-profiles\n+ JWT cookie
  activate REST
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **GetUserProfilesQuery**\n{userId}
  REST --> U: 200 OK\n{profiles: [...]}
  deactivate REST
  note left: Użytkownik może wybrać\nz listy zapisanych profili\nlub nie wybierać żadnego
  
  alt Użytkownik wybiera zapisany profil
    U -> REST: POST /restapi/stalking-request\n{chatId, profileId, social URLs, occasion}\n+ JWT cookie
    activate REST
    REST -> REST: **JwtAuthGuard** - weryfikacja tokena
    REST -> REST: **StartProcessingWithProfileCommand**
    note right: Profil załadowany z bazy i uwzględniony w wywiadzie
  else Użytkownik nie wybiera żadnego profilu
  U -> REST: POST /restapi/stalking-request\n{chatId, social URLs, occasion}\n+ JWT cookie
  activate REST
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **StartProcessingCommand**
  end
else Użytkownik nie ma zapisanych profili
  U -> REST: POST /restapi/stalking-request\n{chatId, social URLs, occasion}\n+ JWT cookie
  activate REST
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **StartProcessingCommand**
end

par Przetwarzanie Równoległe
  REST -> STALK: **StalkingAnalyzeRequestedEvent**\n{chatId, URLs}
  activate STALK
  STALK -> STALK: **StalkingAnalyzeCommand**\n(analiza profili social media)
else
    REST -> CHAT: **ChatStartInterviewEvent**\n{chatId, occasion}
    activate CHAT
    CHAT -> CHAT: **SetOccasionCommand**\n{chatId, occasion}
end

== Interview loop ==
note over CHAT: Wywiad zawsze się odbywa.\nJeśli profil był załadowany,\npierwsze pytanie jest pomijane.
loop Dopóki AI nie zdecyduje zakończyć lub niewłaściwe zachowanie usera
  CHAT -> CHAT: **GenerateQuestionCommand**\n(AI decyduje o następnym pytaniu)
  CHAT --> REST: **ChatQuestionAskedEvent**\n{chatId, question, potentialAnswers}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message
  U -> REST: POST /restapi/send-message\n{chatId, messages}
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **SendUserMessageCommand**
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message\n(echo wiadomości użytkownika)
  REST -> CHAT: **ChatUserAnsweredEvent**\n{chatId, messages}
  CHAT -> CHAT: **GetOccasionQuery**\n{chatId}
end

alt Wywiad zakończony pomyślnie
  CHAT -> CHAT: **closeInterview** toolcall
  CHAT -> GIFT: **ChatInterviewCompletedEvent**\n{chatId, profile}
  activate GIFT
  GIFT -> GIFT: **UpdateInterviewStatusCommand**\n(zapisz profil usera, sprawdź czy stalking gotowy)
  CHAT -> REST: **ChatCompletedNotifyUserEvent**\n{chatId, profile}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-interview-completed\n{profile}
  note left: Wywiad zakończony,\nekran ładowania\n+ opcja zapisu profilu
  
  opt Użytkownik chce zapisać profil do późniejszego użycia
    U -> REST: POST /restapi/save-profile\n{chatId, recipientName}\n+ JWT cookie
    activate REST
    REST -> REST: **JwtAuthGuard** - weryfikacja tokena
    REST -> REST: **SaveUserProfileCommand**\n{userId, chatId, recipientName}
    REST --> U: 201 Created\n{profileId, recipientName}
    deactivate REST
    note left: Profil zapisany,\ndostępny przy kolejnych\nsesji wyszukiwania
  end
else Wykryto niewłaściwe zachowanie
  CHAT -> CHAT: **flagInappropriateRequest** toolcall
  CHAT -> REST: **ChatInappropriateRequestEvent**\n{chatId, reason}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-inappropriate-request
  note left: Wywiad zakończony,\nnagana dla użytkownika
end

deactivate CHAT

== Zakończenie Stalkingu ==
STALK -> GIFT: **StalkingCompletedEvent**\n{keywords, chatId, completedAt}
deactivate STALK
GIFT -> GIFT: **UpdateStalkingStatusCommand**\n(zapisz keywords, sprawdź czy wywiad gotowy)

== Koordynacja Generowania Prezentów ==
note over GIFT: Gdy oba eventy otrzymane

alt Zarówno stalking jak i wywiad zakończone
  GIFT -> GIFT: **GenerateGiftIdeasCommand**\n{userProfile, keywords, chatId}
  note right: AI generuje zapytania wyszukiwania\ndla wielu serwisów
  
  GIFT -> RERANK: **GiftContextInitializedEvent**\n{userProfile, keywords, chatId, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: **InitializeGiftContextCommand**\n(create/update session with context)
 
  par Równoległe Żądania FETCH
  else OLX
    activate FETCH_OLX
    GIFT -> FETCH_OLX: **FetchOlxEvent**\n{query, chatId, eventId, totalEvents}
  else Allegro
    GIFT -> FETCH_ALLEGRO: **FetchAllegroEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_ALLEGRO
  else eBay
    GIFT -> FETCH_EBAY: **FetchEbayEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_EBAY
  else Amazon
    GIFT -> FETCH_AMAZON: **FetchAmazonEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_AMAZON
    note right of FETCH_AMAZON: Wiele zapytań na serwis\nna podstawie decyzji AI
  end
end
deactivate GIFT

== Zbieranie Produktów i Rerankowanie ==
par Odpowiedzi od wszystkich serwisów
else OLX
  FETCH_OLX -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "olx", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: **CreateSessionCommand**\n(ensure session exists)
  RERANK -> RERANK: **AddProductsToSessionCommand**\n(store products with metadata)
  RERANK -> RERANK: **IncrementSessionCompletionCommand**\n(increment completedEvents)
  deactivate RERANK
else Allegro
  FETCH_ALLEGRO -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "allegro", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  deactivate RERANK
else eBay
  FETCH_EBAY -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "ebay", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  deactivate RERANK
else Amazon
  FETCH_AMAZON -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "amazon", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  deactivate RERANK
end
deactivate FETCH_OLX
deactivate FETCH_ALLEGRO
deactivate FETCH_EBAY
deactivate FETCH_AMAZON

note over RERANK
  Reranking Service śledzi completedEvents dla każdego eventId.
  Gdy completedEvents >= totalEvents, automatycznie wywołuje RerankAndEmitGiftReadyCommand.
  Dodatkowy scheduler (@Cron EVERY_30_SECONDS) oznacza sesje jako TIMED_OUT
  jeśli nie otrzymały wszystkich eventów w EVENT_TIMEOUT_MS (default 120s).
end note

alt Wszystkie produkty zebrane (completedEvents >= totalEvents)
  note over RERANK: ProductFetchedHandler wykrywa completed=true
  activate RERANK
  RERANK -> RERANK: **RerankAndEmitGiftReadyCommand**\n{eventId}
  RERANK -> RERANK: **GetSessionProductsQuery**\n{eventId}
  RERANK -> RERANK: **ScoreProductsQuery**\n{products, userProfile, keywords}
  RERANK -> RERANK: **scoreProductsFlow** (AI via Google Gemini)\n(score and reason for each product in batches)
  note right: AI-SDK generateObject z Google Gemini\n(gemini-2.5-flash-lite)\nokreśla score (1-10) i reasoning dla każdego produktu
  RERANK -> RERANK: **UpdateProductRatingsCommand**\n(update products with scores)
  note right: Filtruje produkty z score < 5\nsortuje po score (desc)\nbierze top 50
  RERANK -> REST: **GiftReadyEvent**\n{chatId, rankedProducts[]}
  note right: RERANK emituje event\nz już zrankowanymi produktami\n(score >= 5, sorted desc)
  deactivate RERANK
  activate REST
  REST -> REST: **SaveListingsCommand**\n{chatId, listings[]}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: gift-ready\n{listings with IDs}
  deactivate REST
  note left: Produkty gotowe do wyświetlenia\nużytkownik może dodać do ulubionych
end

@enduml
