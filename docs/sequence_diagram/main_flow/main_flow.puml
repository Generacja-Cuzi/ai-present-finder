@startuml main_flow
title AI Present Finder - Main Flow (Complete with Commands & Events)

actor User as U
participant "REST API" as REST
participant "Google OAuth" as GOOGLE
database "PostgreSQL" as DB
participant "Chat Service" as CHAT
participant "Stalking Service" as STALK
participant "Gift Ideas Service" as GIFT
box "Fetch Microservices" #LightBlue
  participant "OLX" as FETCH_OLX
  participant "Allegro" as FETCH_ALLEGRO
  participant "eBay" as FETCH_EBAY
  participant "Amazon" as FETCH_AMAZON
end box
participant "Reranking Service" as RERANK

== Autoryzacja użytkownika ==
U -> REST: GET /auth/google/url
activate REST
REST -> REST: **GenerateGoogleOAuthUrlQuery**
REST -> GOOGLE: Get OAuth URL
REST --> U: {url: "https://accounts.google.com/..."}
deactivate REST
note left: Użytkownik przekierowuje\ndo Google OAuth

U -> GOOGLE: Autoryzacja w Google
activate GOOGLE
GOOGLE --> U: Redirect z kodem autoryzacyjnym
deactivate GOOGLE

U -> REST: POST /auth/google/callback\n{code}
activate REST
REST -> REST: **ValidateGoogleTokenCommand**
REST -> GOOGLE: Wymiana kodu na token
activate GOOGLE
GOOGLE --> REST: {accessToken, refreshToken, email, name}
deactivate GOOGLE
REST -> DB: Upsert user (email, name, googleTokens)
activate DB
DB --> REST: User entity
deactivate DB
REST -> REST: Generate JWT token
REST --> U: Set-Cookie: access_token (httpOnly)\n{user: {id, email, name}}
deactivate REST
note left: JWT zapisany w httpOnly cookie\nDostęp do chronionych endpointów

== Start sesji (użytkownik zalogowany) ==
U -> REST: POST /restapi/stalking-request\n{chatId, social URLs, occasion}\n+ JWT cookie
activate REST
REST -> REST: **JwtAuthGuard** - weryfikacja tokena
REST -> REST: **StartProcessingCommand**
REST -> DB: Create chat session
activate DB
DB --> REST: Chat entity
deactivate DB

par Przetwarzanie Równoległe
  REST -> STALK: **StalkingAnalyzeRequestedEvent**\n{chatId, URLs}
  activate STALK
  STALK -> STALK: **StalkingAnalyzeCommand**\n(analiza profili social media)
else
  REST -> CHAT: **ChatStartInterviewEvent**\n{chatId, occasion}
  activate CHAT
  CHAT -> CHAT: **SetOccasionCommand**\n{chatId, occasion}
  CHAT -> DB: Create chat session record
  activate DB
  DB --> CHAT: Chat session
  deactivate DB
end

== Interview loop ==
loop Dopóki AI nie zdecyduje zakończyć lub niewłaściwe zachowanie usera
  CHAT -> CHAT: **GenerateQuestionCommand**\n(AI decyduje o następnym pytaniu)
  CHAT --> REST: **ChatQuestionAskedEvent**\n{chatId, question, potentialAnswers}
  REST -> REST: **NotifyUserSseCommand**
  REST -> DB: Save message to database
  activate DB
  DB --> REST: Message entity
  deactivate DB
  REST -> U: SSE: chatbot-message
  U -> REST: POST /restapi/send-message\n{chatId, messages}
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **SendUserMessageCommand**
  REST -> DB: Save user message to database
  activate DB
  DB --> REST: Message entity
  deactivate DB
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message\n(echo wiadomości użytkownika)
  REST -> CHAT: **ChatUserAnsweredEvent**\n{chatId, messages}
  CHAT -> CHAT: **GetOccasionQuery**\n{chatId}
  CHAT -> DB: Fetch occasion from session
  activate DB
  DB --> CHAT: Occasion data
  deactivate DB
end

alt Wywiad zakończony pomyślnie
  CHAT -> CHAT: **closeInterview** toolcall
  CHAT -> GIFT: **ChatInterviewCompletedEvent**\n{chatId, profile}
  activate GIFT
  GIFT -> GIFT: **UpdateInterviewStatusCommand**\n(zapisz profil usera, sprawdź czy stalking gotowy)
  GIFT -> DB: Update chat interview status
  activate DB
  DB --> GIFT: Updated chat
  deactivate DB
  CHAT -> REST: **ChatCompletedNotifyUserEvent**\n{chatId}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-interview-completed
  note left: Wywiad zakończony,\nekran ładowania
else Wykryto niewłaściwe zachowanie
  CHAT -> CHAT: **flagInappropriateRequest** toolcall
  CHAT -> REST: **ChatInappropriateRequestEvent**\n{chatId, reason}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-inappropriate-request
  note left: Wywiad zakończony,\nnagana dla użytkownika
end

deactivate CHAT

== Zakończenie Stalkingu ==
STALK -> GIFT: **StalkingCompletedEvent**\n{keywords, chatId, completedAt}
deactivate STALK
GIFT -> GIFT: **UpdateStalkingStatusCommand**\n(zapisz keywords, sprawdź czy wywiad gotowy)
GIFT -> DB: Update chat stalking status
activate DB
DB --> GIFT: Updated chat
deactivate DB

== Koordynacja Generowania Prezentów ==
note over GIFT: Gdy oba eventy otrzymane

alt Zarówno stalking jak i wywiad zakończone
  GIFT -> GIFT: **GenerateGiftIdeasCommand**\n{userProfile, keywords, chatId}
  note right: AI generuje zapytania wyszukiwania\ndla wielu serwisów (z filtrowaniem disabled services)
  
  GIFT -> GIFT: Generate eventId (ULID)\nand calculate totalEvents
  GIFT -> RERANK: **GiftContextInitializedEvent**\n{userProfile, keywords, chatId, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: **InitializeGiftContextCommand**\n(create/update session with context)
  RERANK -> DB: Create GiftSession with context
  activate DB
  DB --> RERANK: Session created
  deactivate DB
 
  par Równoległe Żądania FETCH
  else OLX
    activate FETCH_OLX
    GIFT -> FETCH_OLX: **FetchOlxEvent**\n{query, chatId, eventId, totalEvents}
  else Allegro
    GIFT -> FETCH_ALLEGRO: **FetchAllegroEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_ALLEGRO
  else eBay
    GIFT -> FETCH_EBAY: **FetchEbayEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_EBAY
  else Amazon
    GIFT -> FETCH_AMAZON: **FetchAmazonEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_AMAZON
    note right of FETCH_AMAZON: Wiele zapytań na serwis\nna podstawie decyzji AI
  end
end
deactivate GIFT

== Zbieranie Produktów i Rerankowanie ==
par Odpowiedzi od wszystkich serwisów
else OLX
  FETCH_OLX -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "olx", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: **CreateSessionCommand**\n(ensure session exists)
  RERANK -> DB: Upsert GiftSession
  activate DB
  DB --> RERANK: Session
  deactivate DB
  RERANK -> RERANK: **AddProductsToSessionCommand**\n(store products with metadata)
  RERANK -> DB: Save Products & GiftSessionProduct
  activate DB
  DB --> RERANK: Products saved
  deactivate DB
  RERANK -> RERANK: **IncrementSessionCompletionCommand**\n(increment completedEvents)
  RERANK -> DB: Update completedEvents counter
  activate DB
  DB --> RERANK: {completed: boolean}
  deactivate DB
  deactivate RERANK
else Allegro
  FETCH_ALLEGRO -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "allegro", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  RERANK -> DB: DB operations
  activate DB
  DB --> RERANK: {completed: boolean}
  deactivate DB
  deactivate RERANK
else eBay
  FETCH_EBAY -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "ebay", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  RERANK -> DB: DB operations
  activate DB
  DB --> RERANK: {completed: boolean}
  deactivate DB
  deactivate RERANK
else Amazon
  FETCH_AMAZON -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "amazon", success, eventId, totalEvents}
  activate RERANK
  RERANK -> RERANK: CreateSession → AddProducts → IncrementCompletion
  RERANK -> DB: DB operations
  activate DB
  DB --> RERANK: {completed: boolean}
  deactivate DB
  deactivate RERANK
end
deactivate FETCH_OLX
deactivate FETCH_ALLEGRO
deactivate FETCH_EBAY
deactivate FETCH_AMAZON

note over RERANK
  Reranking Service śledzi completedEvents dla każdego eventId.
  Gdy completedEvents >= totalEvents, automatycznie wywołuje EmitGiftReadyCommand.
  Dodatkowy scheduler (@Cron EVERY_30_SECONDS) oznacza sesje jako TIMED_OUT
  jeśli nie otrzymały wszystkich eventów w EVENT_TIMEOUT_MS (default 120s).
end note

alt Wszystkie produkty zebrane (completedEvents >= totalEvents)
  note over RERANK: ProductFetchedHandler wykrywa completed=true
  activate RERANK
  RERANK -> RERANK: **EmitGiftReadyCommand**\n{eventId}
  RERANK -> DB: Query GiftSession, GiftSessionProduct, Product
  activate DB
  DB --> RERANK: Session with all products
  deactivate DB
  RERANK -> RERANK: **rankProducts** (AI via OpenAI)\n(score and reason for each product)
  note right: AI-SDK generateObject z OpenAI\nokreśla rating i reasoning dla każdego produktu
  RERANK -> DB: Update Products with rating & reasoning
  activate DB
  DB --> RERANK: Products updated
  deactivate DB
  RERANK -> REST: **GiftReadyEvent**\n{chatId, rankedProducts[]}
  note right: RERANK emituje event\nz już zrankowanymi produktami
  deactivate RERANK
  activate REST
  REST -> REST: **SaveListingsCommand**\n{chatId, listings[]}
  REST -> DB: Save listings to REST API database
  activate DB
  DB --> REST: Saved listings with IDs
  deactivate DB
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: gift-ready\n{listings with database IDs}
  deactivate REST
  note left: Produkty gotowe do wyświetlenia\nużytkownik może dodać do ulubionych
end

@enduml
