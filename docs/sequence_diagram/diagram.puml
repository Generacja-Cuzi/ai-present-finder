@startuml sequence_diagram
title AI Present Finder System - Sequence Diagram of Events and Commands

actor User as U
participant "REST API" as REST
participant "Google OAuth" as GOOGLE
database "PostgreSQL" as DB
participant "Chat Service" as CHAT
participant "Stalking Service" as STALK
participant "Gift Ideas Service" as GIFT
box "Fetch Microservices" #LightBlue
  participant "OLX" as FETCH_OLX
  participant "Allegro" as FETCH_ALLEGRO
  participant "eBay" as FETCH_EBAY
  participant "Amazon" as FETCH_AMAZON
end box
participant "Reranking Service" as RERANK

== Autoryzacja użytkownika ==
U -> REST: GET /auth/google/url
activate REST
REST -> REST: **GenerateGoogleOAuthUrlQuery**
REST --> U: {url: "https://accounts.google.com/..."}
deactivate REST
note left: Użytkownik przekierowuje\ndo Google OAuth

U -> GOOGLE: Autoryzacja w Google
activate GOOGLE
GOOGLE --> U: Redirect z kodem autoryzacyjnym
deactivate GOOGLE

U -> REST: POST /auth/google/callback\n{code}
activate REST
REST -> REST: **ValidateGoogleTokenCommand**
REST -> GOOGLE: Wymiana kodu na token
activate GOOGLE
GOOGLE --> REST: {accessToken, refreshToken, email, name}
deactivate GOOGLE
REST -> DB: Upsert user (email, name, googleTokens)
activate DB
DB --> REST: User entity
deactivate DB
REST -> REST: Generate JWT token
REST --> U: Set-Cookie: access_token (httpOnly)\n{user: {id, email, name}}
deactivate REST
note left: JWT zapisany w httpOnly cookie\nDostęp do chronionych endpointów

== Start sesji (użytkownik zalogowany) ==
U -> REST: POST /restapi/stalking-request\n{chatId, social URLs, occasion}\n+ JWT cookie
activate REST
REST -> REST: **JwtAuthGuard** - weryfikacja tokena
REST -> REST: **StartProcessingCommand**

par Przetwarzanie Równoległe
  REST -> STALK: **StalkingAnalyzeRequestedEvent**\n{chatId, URLs}
  activate STALK
  STALK -> STALK: **StalkingAnalyzeCommand**\n(analiza profili social media)
else
  REST -> CHAT: **ChatStartInterviewEvent**\n{chatId, occasion}
  activate CHAT
  CHAT -> CHAT: **SetOccasionCommand**\n{chatId, occasion}
end

== Interview loop ==
loop Dopóki AI nie zdecyduje zakończyć lub niewłaściwe zachowanie usera
  CHAT -> CHAT: **GenerateQuestionCommand**\n(AI decyduje o następnym pytaniu)
  CHAT --> REST: **ChatQuestionAskedEvent**\n{chatId, question}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message
  U -> REST: POST /restapi/send-message\n{chatId, messages}
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **SendUserMessageCommand**
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message\n(echo wiadomości użytkownika)
  REST -> CHAT: **ChatUserAnsweredEvent**\n{chatId, messages}
  CHAT -> CHAT: **GetOccasionQuery**\n{chatId}
end

alt Wywiad zakończony pomyślnie
  CHAT -> CHAT: **closeInterview** toolcall
  CHAT -> GIFT: **ChatInterviewCompletedEvent**\n{chatId, profile}
  activate GIFT
  GIFT -> GIFT: **UpdateInterviewStatusCommand**\n(zapisz profil usera, sprawdź czy stalking gotowy)
  CHAT -> REST: **ChatCompletedNotifyUserEvent**\n{chatId}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-interview-completed
  note left: Wywiad zakończony,\nekran ładowania
else Wykryto niewłaściwe zachowanie
  CHAT -> CHAT: **flagInappropriateRequest** toolcall
  CHAT -> REST: **ChatInappropriateRequestEvent**\n{chatId, reason}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-inappropriate-request
    note left: Wywiad zakończony, nagana dla użytkownika
end

deactivate CHAT

== Zakończenie Stalkingu ==
STALK -> GIFT: **StalkingCompletedEvent**\n{keywords, chatId, completedAt}
deactivate STALK
GIFT -> GIFT: **UpdateStalkingStatusCommand**\n(zapisz keywords, sprawdź czy wywiad gotowy)

== Koordynacja Generowania Prezentów ==
note over GIFT: Gdy oba eventy otrzymane

alt Zarówno stalking jak i wywiad zakończone
  GIFT -> GIFT: **GenerateGiftIdeasCommand**\n{userProfile, keywords, chatId}
  note right: AI generuje zapytania wyszukiwania\ndla wielu serwisów
  
  GIFT -> RERANK: **GiftContextInitializedEvent**\n{userProfile, keywords, chatId, eventId, totalEvents}
  activate RERANK
 
  par Równoległe Żądania FETCH
  else OLX
    activate FETCH_OLX
    GIFT -> FETCH_OLX: **FetchOlxEvent**\n{query, chatId, eventId, totalEvents}
  else Allegro
    GIFT -> FETCH_ALLEGRO: **FetchAllegroEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_ALLEGRO
  else eBay
    GIFT -> FETCH_EBAY: **FetchEbayEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_EBAY
  else Amazon
    GIFT -> FETCH_AMAZON: **FetchAmazonEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_AMAZON
    note right of FETCH_AMAZON: Wiele zapytań na serwis\nna podstawie decyzji AI
  end
end
deactivate GIFT

== Zbieranie Produktów i Rerankowanie ==
par Odpowiedzi od wszystkich serwisów
else OLX
  FETCH_OLX -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "olx", success, eventId, totalEvents}
else Allegro
  FETCH_ALLEGRO -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "allegro", success, eventId, totalEvents}
else eBay
  FETCH_EBAY -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "ebay", success, eventId, totalEvents}
else Amazon
  FETCH_AMAZON -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "amazon", success, eventId, totalEvents}
end
deactivate FETCH_OLX
deactivate FETCH_ALLEGRO
deactivate FETCH_EBAY
deactivate FETCH_AMAZON

note over RERANK
  Reranking Service śledzi wszystkie przychodzące produkty
  według eventId i czeka, aż wszystkie oczekiwane
  zdarzenia nadejdą (totalEvents)
end note

RERANK -> RERANK: Zbierz i zagreguj produkty\nze wszystkich źródeł

alt Wszystkie produkty zebrane (lub timeout)
  RERANK -> RERANK: AI rerankowanie i filtrowanie\n(na podstawie profilu + słów kluczowych)
  RERANK -> REST: **GiftReadyEvent**\n{chatId, giftIdeas[]}
  deactivate RERANK
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: gift-ready
  deactivate REST
end

@enduml
