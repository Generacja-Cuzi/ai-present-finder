@startuml C4_Component_Reranking
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

Container_Boundary(reranking, "Reranking Microservice (NestJS)") {
  Component(context_handler, "GiftContextInitializedHandler", "Event Handler", "Consumes GiftContextInitializedEvent, delegates to InitializeGiftContextCommand")
  Component(product_handler, "ProductFetchedHandler", "Event Handler", "Consumes ProductFetchedEvent, orchestrates session creation, product storage, and completion tracking")
  
  Component(create_session, "CreateSessionHandler", "Command Handler", "Creates or ensures session exists for eventId")
  Component(init_context, "InitializeGiftContextHandler", "Command Handler", "Initializes gift context. On regeneration: adds new totalEvents to existing, resets status to ACTIVE")
  Component(add_products, "AddProductsToSessionHandler", "Command Handler", "Stores products in session with source event metadata")
  Component(increment_completion, "IncrementSessionCompletionHandler", "Command Handler", "Increments completed events counter, marks session as complete when done")
  Component(emit_ready, "RerankAndEmitGiftReadyHandler", "Command Handler", "Scores only unscored products, filters by MINIMAL_SCORE (env: default 7), checks if regeneration needed")
  Component(check_regenerate, "CheckAndPrepareRegenerateIdeasLoopHandler", "Command Handler", "Checks if good products < TOP_BEST_COUNT and loopCount < MAX_IDEAS_LOOP, prepares RegenerateIdeasLoopEvent")
  Component(mark_timeout, "MarkTimeoutSessionsHandler", "Command Handler", "Marks inactive sessions as timed out based on EVENT_TIMEOUT_MS")
  Component(get_session_products, "GetSessionProductsHandler", "Query Handler", "Handles GetSessionProductsQuery, retrieves session and all products")
  Component(score_products, "ScoreProductsHandler", "Query Handler", "Handles ScoreProductsQuery, batches products (50 per batch), and calls scoreProductsFlow")
  Component(update_ratings, "UpdateProductRatingsHandler", "Command Handler", "Handles UpdateProductRatingsCommand, updates products with scores and reasoning")
  
  Component(ranking_service, "scoreProductsFlow", "AI Service", "Uses Google Gemini (gemini-2.5-flash-lite) via ai-sdk to score products based on user profile and keywords")
  
  Component(gift_session_repo, "GiftSessionRepository", "TypeORM Repository", "CRUD operations for GiftSession (eventId, chatId, status, completedEvents, totalEvents, loopCount, giftContext)")
  Component(session_product_repo, "GiftSessionProductRepository", "TypeORM Repository", "CRUD operations for GiftSessionProduct (join table with source event metadata)")
  Component(product_repo, "ProductRepository", "TypeORM Repository", "CRUD operations for Product (image, title, description, price, rating, reasoning)")
  
  ComponentDb(database, "PostgreSQL", "Database", "TypeORM persistence layer")
}

Component_Ext(rabbitmq_in_context, "RabbitMQ", "Message Broker", "GiftContextInitializedEvent queue")
Component_Ext(rabbitmq_in_product, "RabbitMQ", "Message Broker", "ProductFetchedEvent queue")
Component_Ext(rabbitmq_out_ready, "RabbitMQ", "Message Broker", "GiftReadyEvent queue")
Component_Ext(rabbitmq_out_regenerate, "RabbitMQ", "Message Broker", "RegenerateIdeasLoopEvent queue")

' Event handler relationships
Rel(rabbitmq_in_context, context_handler, "Consumes", "AMQP @EventPattern")
Rel(context_handler, init_context, "Executes", "CommandBus")

Rel(rabbitmq_in_product, product_handler, "Consumes", "AMQP @EventPattern")
Rel(product_handler, create_session, "1. Creates session", "CommandBus")
Rel(product_handler, add_products, "2. Adds products", "CommandBus")
Rel(product_handler, increment_completion, "3. Increments counter", "CommandBus")
Rel(product_handler, emit_ready, "4. Emits when complete", "CommandBus (conditional)")

' Command handler to repository/database relationships
Rel(create_session, gift_session_repo, "Creates/reads", "TypeORM Repository")
Rel(gift_session_repo, database, "Persists", "TypeORM")
Rel(init_context, gift_session_repo, "Creates/updates context", "TypeORM Repository")
Rel(add_products, session_product_repo, "Creates", "TypeORM Repository")
Rel(add_products, product_repo, "Creates", "TypeORM Repository")
Rel(session_product_repo, database, "Persists", "TypeORM")
Rel(product_repo, database, "Persists", "TypeORM")
Rel(increment_completion, gift_session_repo, "Updates completion count", "TypeORM Repository")
Rel(emit_ready, get_session_products, "Executes GetSessionProductsQuery", "QueryBus")
Rel(get_session_products, gift_session_repo, "Reads session", "TypeORM Repository")
Rel(get_session_products, session_product_repo, "Reads with products", "TypeORM Repository")
Rel(emit_ready, score_products, "Executes ScoreProductsQuery (only unscored)", "QueryBus")
Rel(score_products, ranking_service, "Scores products in batches", "AI via generateObject")
Rel(emit_ready, update_ratings, "Executes UpdateProductRatingsCommand", "CommandBus")
Rel(update_ratings, product_repo, "Updates scores/reasoning", "TypeORM Repository")
Rel(emit_ready, check_regenerate, "Executes CheckAndPrepareRegenerateIdeasLoopCommand", "CommandBus")
Rel(check_regenerate, gift_session_repo, "Reads/updates loopCount", "TypeORM Repository")
Rel(emit_ready, rabbitmq_out_ready, "Publishes (if enough products)", "AMQP ClientProxy.emit")
Rel(emit_ready, rabbitmq_out_regenerate, "Publishes (if regeneration needed)", "AMQP ClientProxy.emit")
Rel(mark_timeout, gift_session_repo, "Updates status", "TypeORM Repository")

SHOW_LEGEND()
@enduml
