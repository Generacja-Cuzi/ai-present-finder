@startuml main_flow
title AI Present Finder - Main Flow (Complete with Commands & Events)

actor User as U
participant "REST API" as REST
participant "Google OAuth" as GOOGLE
database "PostgreSQL" as DB
participant "Chat Service" as CHAT
participant "Stalking Service" as STALK
participant "Gift Ideas Service" as GIFT
box "Fetch Microservices" #LightBlue
  participant "OLX" as FETCH_OLX
  participant "Allegro" as FETCH_ALLEGRO
  participant "eBay" as FETCH_EBAY
  participant "Amazon" as FETCH_AMAZON
end box
participant "Reranking Service" as RERANK

== Autoryzacja użytkownika ==
U -> REST: GET /auth/google/url
activate REST
REST -> REST: **GenerateGoogleOAuthUrlQuery**
REST -> GOOGLE: Get OAuth URL
REST --> U: {url: "https://accounts.google.com/..."}
deactivate REST
note left: Użytkownik przekierowuje\ndo Google OAuth

U -> GOOGLE: Autoryzacja w Google
activate GOOGLE
GOOGLE --> U: Redirect z kodem autoryzacyjnym
deactivate GOOGLE

U -> REST: POST /auth/google/callback\n{code}
activate REST
REST -> REST: **ValidateGoogleTokenCommand**
REST -> GOOGLE: Wymiana kodu na token
activate GOOGLE
GOOGLE --> REST: {accessToken, refreshToken, email, name}
deactivate GOOGLE
REST -> DB: Upsert user (email, name, googleTokens)
activate DB
DB --> REST: User entity
deactivate DB
REST -> REST: Generate JWT token
REST --> U: Set-Cookie: access_token (httpOnly)\n{user: {id, email, name}}
deactivate REST
note left: JWT zapisany w httpOnly cookie\nDostęp do chronionych endpointów

== Start sesji (użytkownik zalogowany) ==
U -> REST: POST /restapi/stalking-request\n{chatId, social URLs, occasion}\n+ JWT cookie
activate REST
REST -> REST: **JwtAuthGuard** - weryfikacja tokena
REST -> REST: **StartProcessingCommand**
REST -> DB: Create chat session
activate DB
DB --> REST: Chat entity
deactivate DB

par Przetwarzanie Równoległe
  REST -> STALK: **StalkingAnalyzeRequestedEvent**\n{chatId, URLs}
  activate STALK
  STALK -> STALK: **StalkingAnalyzeCommand**\n(analiza profili social media)
else
  REST -> CHAT: **ChatStartInterviewEvent**\n{chatId, occasion}
  activate CHAT
  CHAT -> CHAT: **SetOccasionCommand**\n{chatId, occasion}
  CHAT -> DB: Create chat session record
  activate DB
  DB --> CHAT: Chat session
  deactivate DB
end

== Interview loop ==
loop Dopóki AI nie zdecyduje zakończyć lub niewłaściwe zachowanie usera
  CHAT -> CHAT: **GenerateQuestionCommand**\n(AI decyduje o następnym pytaniu)
  CHAT --> REST: **ChatQuestionAskedEvent**\n{chatId, question}
  REST -> REST: **NotifyUserSseCommand**
  REST -> DB: Save message to database
  activate DB
  DB --> REST: Message entity
  deactivate DB
  REST -> U: SSE: chatbot-message
  U -> REST: POST /restapi/send-message\n{chatId, messages}
  REST -> REST: **JwtAuthGuard** - weryfikacja tokena
  REST -> REST: **SendUserMessageCommand**
  REST -> DB: Save user message to database
  activate DB
  DB --> REST: Message entity
  deactivate DB
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chatbot-message\n(echo wiadomości użytkownika)
  REST -> CHAT: **ChatUserAnsweredEvent**\n{chatId, messages}
  CHAT -> CHAT: **GetOccasionQuery**\n{chatId}
  CHAT -> DB: Fetch occasion from session
  activate DB
  DB --> CHAT: Occasion data
  deactivate DB
end

alt Wywiad zakończony pomyślnie
  CHAT -> CHAT: **closeInterview** toolcall
  CHAT -> GIFT: **ChatInterviewCompletedEvent**\n{chatId, profile}
  activate GIFT
  GIFT -> GIFT: **UpdateInterviewStatusCommand**\n(zapisz profil usera, sprawdź czy stalking gotowy)
  GIFT -> DB: Update chat interview status
  activate DB
  DB --> GIFT: Updated chat
  deactivate DB
  CHAT -> REST: **ChatCompletedNotifyUserEvent**\n{chatId}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-interview-completed
  note left: Wywiad zakończony,\nekran ładowania
else Wykryto niewłaściwe zachowanie
  CHAT -> CHAT: **flagInappropriateRequest** toolcall
  CHAT -> REST: **ChatInappropriateRequestEvent**\n{chatId, reason}
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: chat-inappropriate-request
  note left: Wywiad zakończony,\nnagana dla użytkownika
end

deactivate CHAT

== Zakończenie Stalkingu ==
STALK -> GIFT: **StalkingCompletedEvent**\n{keywords, chatId, completedAt}
deactivate STALK
GIFT -> GIFT: **UpdateStalkingStatusCommand**\n(zapisz keywords, sprawdź czy wywiad gotowy)
GIFT -> DB: Update chat stalking status
activate DB
DB --> GIFT: Updated chat
deactivate DB

== Koordynacja Generowania Prezentów ==
note over GIFT: Gdy oba eventy otrzymane

alt Zarówno stalking jak i wywiad zakończone
  GIFT -> GIFT: **GenerateGiftIdeasCommand**\n{userProfile, keywords, chatId}
  note right: AI generuje zapytania wyszukiwania\ndla wielu serwisów
  
  GIFT -> RERANK: **GiftContextInitializedEvent**\n{userProfile, keywords, chatId, eventId, totalEvents}
  activate RERANK
 
  par Równoległe Żądania FETCH
  else OLX
    activate FETCH_OLX
    GIFT -> FETCH_OLX: **FetchOlxEvent**\n{query, chatId, eventId, totalEvents}
  else Allegro
    GIFT -> FETCH_ALLEGRO: **FetchAllegroEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_ALLEGRO
  else eBay
    GIFT -> FETCH_EBAY: **FetchEbayEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_EBAY
  else Amazon
    GIFT -> FETCH_AMAZON: **FetchAmazonEvent**\n{query, chatId, eventId, totalEvents}
    activate FETCH_AMAZON
    note right of FETCH_AMAZON: Wiele zapytań na serwis\nna podstawie decyzji AI
  end
end
deactivate GIFT

== Zbieranie Produktów i Rerankowanie ==
par Odpowiedzi od wszystkich serwisów
else OLX
  FETCH_OLX -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "olx", success, eventId, totalEvents}
else Allegro
  FETCH_ALLEGRO -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "allegro", success, eventId, totalEvents}
else eBay
  FETCH_EBAY -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "ebay", success, eventId, totalEvents}
else Amazon
  FETCH_AMAZON -> RERANK: **ProductFetchedEvent**\n{products[], chatId, provider: "amazon", success, eventId, totalEvents}
end
deactivate FETCH_OLX
deactivate FETCH_ALLEGRO
deactivate FETCH_EBAY
deactivate FETCH_AMAZON

note over RERANK
  Reranking Service śledzi wszystkie przychodzące produkty
  według eventId i czeka, aż wszystkie oczekiwane
  zdarzenia nadejdą (totalEvents)
end note

RERANK -> RERANK: Zbierz i zagreguj produkty\nze wszystkich źródeł

alt Wszystkie produkty zebrane (lub timeout)
  RERANK -> RERANK: AI rerankowanie i filtrowanie\n(na podstawie profilu + słów kluczowych)
  RERANK -> REST: **GiftReadyEvent**\n{chatId, giftIdeas[]}
  deactivate RERANK
  activate REST
  REST -> REST: **SaveListingsCommand**\n{chatId, listings[]}
  REST -> DB: Save all product listings
  activate DB
  DB --> REST: Saved listings with IDs
  deactivate DB
  REST -> DB: Associate listings with chat
  activate DB
  DB --> REST: Chat with listings
  deactivate DB
  REST -> REST: **NotifyUserSseCommand**
  REST -> U: SSE: gift-ready\n{listings with database IDs}
  deactivate REST
  note left: Produkty gotowe do wyświetlenia\nużytkownik może dodać do ulubionych
end

@enduml
